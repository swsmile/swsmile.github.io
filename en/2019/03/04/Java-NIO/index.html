<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword" content="">
    <link rel="shortcut icon" href="/en/img/ironman-draw.png">
    <!-- Place this tag in your head or just before your close body tag. -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>
    <title>
        
          [Java] NIO - Wei&#39;s Blog
        
    </title>

    <link rel="canonical" href="http://swsmile.info/en/2019/03/04/Java-NIO/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/en/css/bootstrap.min.css">

    <!-- Custom CSS --> 
    <link rel="stylesheet" href="/en/css/beantech.min.css">
    
    <!-- Pygments Highlight CSS -->
    <link rel="stylesheet" href="/en/css/highlight.css">

    <link rel="stylesheet" href="/en/css/widget.css">

    <link rel="stylesheet" href="/en/css/rocket.css">

    <link rel="stylesheet" href="/en/css/signature.css">

    <link rel="stylesheet" href="/en/css/toc.css">

    <!-- Custom Fonts -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">
	<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        
            background-image: url('../../../../img/tag-bg.png')
            /*post*/
        
    }
    
    #signature{
        background-image: url('/en/img/signature/BeanTechSign-white.png');
    }
    
</style>

<header class="intro-header">
    <!-- Signature -->
    <div id="signature">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                
                    <div class="post-heading">
                        <div class="tags">
                            
                              <a class="tag" href="/en/tags/#Java" title="Java">Java</a>
                            
                        </div>
                        <h1>[Java] NIO</h1>
                        <h2 class="subheading"></h2>
                        <span class="meta">
                            Posted by Wei Shi on
                            2019-03-04
                        </span>
                    </div>
                


                </div>
            </div>
        </div>
    </div>
</header>

	
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/en/">Wei&#39;s Blog</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/en/">Home</a>
                    </li>

                    

                        
                        <li>
                            <a href="/en/about/">About</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/en/archive/">Archives</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/en/tags/">Tags</a>
                        </li>
                        
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    <!-- Modify by Yu-Hsuan Yen -->

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <h1><span id="channels">Channels</span></h1>
<p>Java NIO Channels are similar to streams with a few differences:</p>
<ul>
<li>You can both read and write to a Channels. Streams are typically one-way (read or write).</li>
<li>Channels can be read and written asynchronously.</li>
<li>Channels always read to, or write from, a Buffer.</li>
</ul>
<h2><span id="channels-and-buffers">Channels and Buffers</span></h2>
<p>From the <code>Channel</code> data can be read into a <code>Buffer</code>. Data can also be written from a <code>Buffer</code> into a <code>Channel</code>.</p>
<p><img src="/en/pic/image-20190304111210340.png" alt="image-20190304111210340"></p>
<h2><span id="types-of-channels">Types of Channels</span></h2>
<p>Here are the most important Channel implementations in Java NIO:</p>
<ul>
<li>FileChannel</li>
<li>DatagramChannel</li>
<li>SocketChannel</li>
<li>ServerSocketChannel</li>
</ul>
<p>The <code>FileChannel</code> reads data from and to files.</p>
<p>The <code>DatagramChannel</code> can read and write data over the network via UDP.</p>
<p>The <code>SocketChannel</code> can read and write data over the network via TCP.</p>
<p>The <code>ServerSocketChannel</code> allows you to listen for incoming TCP connections, like a web server does. For each incoming connection a <code>SocketChannel</code> is created.</p>
<p>As you can see, these channels cover UDP + TCP network IO, and file IO.</p>
<h1><span id="example">Example</span></h1>
<p>Here is a basic example that uses a <code>FileChannel</code> to read some data into a <code>Buffer</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile aFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"data/nio-data.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel inChannel = aFile.getChannel();</span><br><span class="line"></span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bytesRead = inChannel.read(buf);</span><br><span class="line"><span class="keyword">while</span> (bytesRead != -<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">"Read "</span> + bytesRead);</span><br><span class="line">  buf.flip();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(buf.hasRemaining())&#123;</span><br><span class="line">      System.out.print((<span class="keyword">char</span>) buf.get());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  buf.clear();</span><br><span class="line">  bytesRead = inChannel.read(buf);</span><br><span class="line">&#125;</span><br><span class="line">aFile.close();</span><br></pre></td></tr></table></figure>
<p>Notice the <code>buf.flip()</code> call. First you read into a Buffer. Then you flip it. Then you read out of it. I’ll get into more detail about that in the next text about <code>Buffer</code>'s.</p>
<h1><span id="buffers">Buffers</span></h1>
<p>Java NIO Buffers are used when interacting with NIO Channels. As you know, data is read from channels into buffers, and written from buffers into channels.</p>
<p>A buffer is essentially a block of memory into which you can write data, which you can then later read again. This memory block is wrapped in a NIO Buffer object, which provides a set of methods that makes it easier to work with the memory block.</p>
<h2><span id="basic-buffer-usage">Basic Buffer Usage</span></h2>
<p>Using a <code>Buffer</code> to read and write data typically follows this little 4-step process:</p>
<ol>
<li>Write data into the Buffer</li>
<li>Call <code>buffer.flip()</code></li>
<li>Read data out of the Buffer</li>
<li>Call <code>buffer.clear()</code> or <code>buffer.compact()</code></li>
</ol>
<p>When you write data into a buffer, the buffer keeps track of how much data you have written. Once you need to read the data, you need to switch the buffer from writing mode into reading mode using the <code>flip()</code> method call. In reading mode the buffer lets you read all the data written into the buffer.</p>
<p>Once you have read all the data, you need to clear the buffer, to make it ready for writing again. You can do this in two ways: By calling <code>clear()</code> or by calling <code>compact()</code>. The <code>clear()</code> method clears the whole buffer. The <code>compact()</code> method only clears the data which you have already read. Any unread data is moved to the beginning of the buffer, and data will now be written into the buffer after the unread data.</p>
<p>Here is a simple <code>Buffer</code> usage example, with the write, flip, read and clear operations maked in bold:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile aFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"data/nio-data.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel inChannel = aFile.getChannel();</span><br><span class="line"></span><br><span class="line"><span class="comment">//create buffer with capacity of 48 bytes</span></span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bytesRead = inChannel.read(buf); <span class="comment">//read into buffer.</span></span><br><span class="line"><span class="keyword">while</span> (bytesRead != -<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">  buf.flip();  <span class="comment">//make buffer ready for read</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(buf.hasRemaining())&#123;</span><br><span class="line">      System.out.print((<span class="keyword">char</span>) buf.get()); <span class="comment">// read 1 byte at a time</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  buf.clear(); <span class="comment">//make buffer ready for writing</span></span><br><span class="line">  bytesRead = inChannel.read(buf);</span><br><span class="line">&#125;</span><br><span class="line">aFile.close();</span><br></pre></td></tr></table></figure>
<h3><span id="buffer-capacity-position-and-limit">Buffer Capacity, Position and Limit</span></h3>
<p>A buffer is essentially a block of memory into which you can write data, which you can then later read again. This memory block is wrapped in a NIO Buffer object, which provides a set of methods that makes it easier to work with the memory block.</p>
<p>A <code>Buffer</code> has three properties you need to be familiar with, in order to understand how a <code>Buffer</code> works. These are:</p>
<ul>
<li>capacity</li>
<li>position</li>
<li>limit</li>
</ul>
<p>The meaning of <code>position</code> and <code>limit</code> depends on whether the <code>Buffer</code> is in read or write mode. Capacity always means the same, no matter the buffer mode.</p>
<p>Here is an illustration of capacity, position and limit in write and read modes. The explanation follows in the sections after the illustration.</p>
<p><img src="/en/pic/image-20190304112755809.png" alt="image-20190304112755809"></p>
<h3><span id="capacity">Capacity</span></h3>
<p>Being a memory block, a <code>Buffer</code> has a certain fixed size, also called its “capacity”. You can only write <code>capacity</code> bytes, longs, chars etc. into the Buffer. Once the Buffer is full, you need to empty it (read the data, or clear it) before you can write more data into it.</p>
<h3><span id="position">Position</span></h3>
<p>When you write data into the <code>Buffer</code>, you do so at a certain position. Initially the position is 0. When a byte, long etc. has been written into the <code>Buffer</code> the position is advanced to point to the next cell in the buffer to insert data into. Position can maximally become <code>capacity - 1</code>.</p>
<p>When you read data from a <code>Buffer</code> you also do so from a given position. When you flip a <code>Buffer</code> from writing mode to reading mode, the position is reset back to 0. As you read data from the <code>Buffer</code> you do so from <code>position</code>, and <code>position</code> is advanced to next position to read.</p>
<h3><span id="limit">Limit</span></h3>
<p>In write mode the limit of a <code>Buffer</code> is the limit of how much data you can write into the buffer. In write mode the limit is equal to the capacity of the <code>Buffer</code>.</p>
<p>When flipping the <code>Buffer</code> into read mode, limit means the limit of how much data you can read from the data. Therefore, when flipping a <code>Buffer</code> into read mode, limit is set to write position of the write mode. In other words, you can read as many bytes as were written (limit is set to the number of bytes written, which is marked by position).</p>
<h2><span id="buffer-types">Buffer Types</span></h2>
<p>Java NIO comes with the following <strong>Buffer</strong> types:</p>
<ul>
<li>ByteBuffer</li>
<li>MappedByteBuffer</li>
<li>CharBuffer</li>
<li>DoubleBuffer</li>
<li>FloatBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>ShortBuffer</li>
</ul>
<p>As you can see, these <code>Buffer</code> types represent different data types. In other words, they let you work with the bytes in the buffer as char, short, int, long, float or double instead.</p>
<h2><span id="allocating-a-buffer">Allocating a Buffer</span></h2>
<p>To obtain a <code>Buffer</code> object you must first allocate it. Every <code>Buffer</code>class has an <code>allocate()</code> method that does this. Here is an example showing the allocation of a <code>ByteBuffer</code>, with a capacity of 48 bytes:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(48);</span><br></pre></td></tr></table></figure>
<p>Here is an example allocating a <code>CharBuffer</code> with space for 1024 characters:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CharBuffer buf = CharBuffer.allocate(1024);</span><br></pre></td></tr></table></figure>
<h2><span id="writing-data-to-a-buffer">Writing Data to a Buffer</span></h2>
<p>You can write data into a <code>Buffer</code> in two ways:</p>
<ol>
<li>Write data from a <code>Channel</code> into a <code>Buffer</code></li>
<li>Write data into the <code>Buffer</code> yourself, via the buffer’s <code>put()</code>methods.</li>
</ol>
<p>Here is an example showing how a <code>Channel</code> can write data into a <code>Buffer</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int bytesRead = inChannel.read(buf); //read into buffer.</span><br></pre></td></tr></table></figure>
<p>Here is an example that writes data into a <code>Buffer</code> via the <code>put()</code>method:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.put(127);</span><br></pre></td></tr></table></figure>
<p>There are many other versions of the <code>put()</code> method, allowing you to write data into the <code>Buffer</code> in many different ways. For instance, writing at specific positions, or writing an array of bytes into the buffer. See the JavaDoc for the concrete buffer implementation for more details.</p>
<h2><span id="flip">flip()</span></h2>
<p>The <code>flip()</code> method switches a <code>Buffer</code> from writing mode to reading mode. Calling <code>flip()</code> sets the <code>position</code> back to 0, and sets the <code>limit</code> to where position just was.</p>
<p>In other words, <code>position</code> now marks the reading position, and <code>limit</code> marks how many bytes, chars etc. were written into the buffer - the limit of how many bytes, chars etc. that can be read.</p>
<h2><span id="reading-data-from-a-buffer">Reading Data from a Buffer</span></h2>
<p>There are two ways you can read data from a <code>Buffer</code>.</p>
<ol>
<li>Read data from the buffer into a channel.</li>
<li>Read data from the buffer yourself, using one of the get() methods.</li>
</ol>
<p>Here is an example of how you can read data from a buffer into a channel:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//read from buffer into channel.</span><br><span class="line">int bytesWritten = inChannel.write(buf);</span><br></pre></td></tr></table></figure>
<p>Here is an example that reads data from a <code>Buffer</code> using the get() method:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">byte aByte = buf.get();</span><br></pre></td></tr></table></figure>
<p>There are many other versions of the <code>get()</code> method, allowing you to read data from the <code>Buffer</code> in many different ways. For instance, reading at specific positions, or reading an array of bytes from the buffer.</p>
<h2><span id="rewind">rewind()</span></h2>
<p>The <code>Buffer.rewind()</code> sets the <code>position</code> back to 0, so you can reread all the data in the buffer. The <code>limit</code> remains untouched, thus still marking how many elements (bytes, chars etc.) that can be read from the <code>Buffer</code>.</p>
<h2><span id="clear-and-compact">clear() and compact()</span></h2>
<p>Once you are done reading data out of the <code>Buffer</code> you have to make the <code>Buffer</code> ready for writing again. You can do so either by calling <code>clear()</code> or by calling <code>compact()</code>.</p>
<p>If you call <code>clear()</code> the <code>position</code> is set back to 0 and the <code>limit</code> to<code>capacity</code>. In other words, the <code>Buffer</code> is cleared. The data in the <code>Buffer</code> is not cleared. Only the markers telling where you can write data into the <code>Buffer</code> are.</p>
<p>If there is any unread data in the <code>Buffer</code> when you call <code>clear()</code>that data will be “forgotten”, meaning you no longer have any markers telling what data has been read, and what has not been read.</p>
<p>If there is still unread data in the <code>Buffer</code>, and you want to read it later, but you need to do some writing first, call <code>compact()</code> instead of <code>clear()</code>.</p>
<p><code>compact()</code> copies all unread data to the beginning of the <code>Buffer</code>. Then it sets <code>position</code> to right after the last unread element. The <code>limit</code> property is still set to <code>capacity</code>, just like <code>clear()</code> does. Now the <code>Buffer</code> is ready for writing, but you will not overwrite the unread data.</p>
<h2><span id="mark-and-reset">mark() and reset()</span></h2>
<p>You can mark a given position in a <code>Buffer</code> by calling the <code>Buffer.mark()</code> method. You can then later reset the position back to the marked position by calling the <code>Buffer.reset()</code> method. Here is an example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">buffer.mark();</span><br><span class="line"></span><br><span class="line">//call buffer.get() a couple of times, e.g. during parsing.</span><br><span class="line"></span><br><span class="line">buffer.reset();  //set position back to mark.</span><br></pre></td></tr></table></figure>
<h2><span id="equals-and-compareto">equals() and compareTo()</span></h2>
<p>It is possible to compare two buffers using <code>equals()</code> and <code>compareTo()</code>.</p>
<h2><span id="equals">equals()</span></h2>
<p>Two buffers are equal if:</p>
<ol>
<li>They are of the same type (byte, char, int etc.)</li>
<li>They have the same amount of remaining bytes, chars etc. in the buffer.</li>
<li>All remaining bytes, chars etc. are equal.</li>
</ol>
<p>As you can see, equals only compares part of the <code>Buffer</code>, not every single element inside it. In fact, it just compares the remaining elements in the <code>Buffer</code>.</p>
<h2><span id="compareto">compareTo()</span></h2>
<p>The <code>compareTo()</code> method compares the remaining elements (bytes, chars etc.) of the two buffers, for use in e.g. sorting routines. A buffer is considered “smaller” than another buffer if:</p>
<ol>
<li>The first element which is equal to the corresponding element in the other buffer, is smaller than that in the other buffer.</li>
<li>All elements are equal, but the first buffer runs out of elements before the second buffer does (it has fewer elements).</li>
</ol>
<h1><span id="java-nio-scatter-gather">Java NIO Scatter / Gather</span></h1>
<p>Java NIO comes with built-in scatter / gather support. Scatter / gather are concepts used in reading from, and writing to channels.</p>
<p>A scattering read from a channel is a read operation that reads data into more than one buffer. Thus, the channel “scatters” the data from the channel into multiple buffers.</p>
<p>A gathering write to a channel is a write operation that writes data from more than one buffer into a single channel. Thus, the channel “gathers” the data from multiple buffers into one channel.</p>
<p>Scatter / gather can be really useful in situations where you need to work with various parts of the transmitted data separately. For instance, if a message consists of a header and a body, you might keep the header and body in separate buffers. Doing so may make it easier for you to work with header and body separately.</p>
<h2><span id="scattering-reads">Scattering Reads</span></h2>
<p>A “scattering read” reads data from a single channel into multiple buffers. Here is an illustration of that principle:</p>
<p>Here is an illustration of the <code>Scatter</code> principle:</p>
<p><img src="/en/pic/image-20190304114319694.png" alt="image-20190304114319694"></p>
<p>Here is a code example that shows how to perform a scattering read:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer header = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">ByteBuffer body   = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">ByteBuffer[] bufferArray = &#123; header, body &#125;;</span><br><span class="line"></span><br><span class="line">channel.read(bufferArray);</span><br></pre></td></tr></table></figure>
<p>Notice how the buffers are first inserted into an array, then the array passed as parameter to the <code>channel.read()</code> method. The <code>read()</code>method then writes data from the channel in the sequence the buffers occur in the array. Once a buffer is full, the channel moves on to fill the next buffer.</p>
<p>The fact that scattering reads fill up one buffer before moving on to the next, means that it is not suited for dynamically sized message parts. In other words, if you have a header and a body, and the header is fixed size (e.g. 128 bytes), then a scattering read works fine.</p>
<h2><span id="gathering-writes">Gathering Writes</span></h2>
<p>A “gathering write” writes data from multiple buffers into a single channel. Here is an illustration of that principle:</p>
<p><img src="/en/pic/image-20190304114416705.png" alt="image-20190304114416705"></p>
<p>Here is a code example that shows how to perform a gathering write:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer header = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">ByteBuffer body   = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//write data into buffers</span></span><br><span class="line"></span><br><span class="line">ByteBuffer[] bufferArray = &#123; header, body &#125;;</span><br><span class="line"></span><br><span class="line">channel.write(bufferArray);</span><br></pre></td></tr></table></figure>
<p>The array of buffers are passed into the <code>write()</code> method, which writes the content of the buffers in the sequence they are encountered in the array. Only the data between position and limit of the buffers is written. Thus, if a buffer has a capacity of 128 bytes, but only contains 58 bytes, only 58 bytes are written from that buffer to the channel. Thus, a gathering write works fine with dynamically sized message parts, in contrast to scattering reads.</p>
<p>n Java NIO you can transfer data directly from one channel to another, if one of the channels is a <code>FileChannel</code>. The <code>FileChannel</code> class has a <code>transferTo()</code> and a <code>transferFrom()</code> method which does this for you.</p>
<h1><span id="java-nio-channel-to-channel-transfers">Java NIO Channel to Channel Transfers</span></h1>
<h2><span id="transferfrom">transferFrom()</span></h2>
<p>The <code>FileChannel.transferFrom()</code> method transfers data from a source channel into the <code>FileChannel</code>. Here is a simple example:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile fromFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"fromFile.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel      fromChannel = fromFile.getChannel();</span><br><span class="line"></span><br><span class="line">RandomAccessFile toFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"toFile.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel      toChannel = toFile.getChannel();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> position = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> count    = fromChannel.size();</span><br><span class="line"></span><br><span class="line">toChannel.transferFrom(fromChannel, position, count);</span><br></pre></td></tr></table></figure>
<p>The parameters position and count, tell where in the destination file to start writing (<code>position</code>), and how many bytes to transfer maximally (<code>count</code>). If the source channel has fewer than <code>count</code> bytes, less is transfered.</p>
<p>Additionally, some <code>SocketChannel</code> implementations may transfer only the data the <code>SocketChannel</code> has ready in its internal buffer here and now - even if the <code>SocketChannel</code> may later have more data available. Thus, it may not transfer the entire data requested (<code>count</code>) from the <code>SocketChannel</code> into <code>FileChannel</code>.</p>
<h2><span id="transferto">transferTo()</span></h2>
<p>The <code>transferTo()</code> method transfer from a <code>FileChannel</code> into some other channel. Here is a simple example:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile fromFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"fromFile.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel      fromChannel = fromFile.getChannel();</span><br><span class="line"></span><br><span class="line">RandomAccessFile toFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"toFile.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel      toChannel = toFile.getChannel();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> position = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> count    = fromChannel.size();</span><br><span class="line"></span><br><span class="line">fromChannel.transferTo(position, count, toChannel);</span><br></pre></td></tr></table></figure>
<p>Notice how similar the example is to the previous. The only real difference is the which <code>FileChannel</code> object the method is called on. The rest is the same.</p>
<p>The issue with <code>SocketChannel</code> is also present with the <code>transferTo()</code> method. The <code>SocketChannel</code> implementation may only transfer bytes from the <code>FileChannel</code> until the send buffer is full, and then stop.</p>
<h1><span id="selectors">Selectors</span></h1>
<p>The Java NIO Selector is a component which can examine one or more Java NIO Channel instances, and determine which channels are ready for e.g. reading or writing. This way a single thread can manage multiple channels, and thus multiple network connections.</p>
<h2><span id="why-use-a-selector">Why Use a Selector?</span></h2>
<p>The advantage of using just a single thread to handle multiple channels is that you need less threads to handle the channels. Actually, you can use just one thread to handle all of your channels. Switching between threads is expensive for an operating system, and each thread takes up some resources (memory) in the operating system too. Therefore, the less threads you use, the better.</p>
<p>Keep in mind though, that modern operating systems and CPU’s become better and better at multitasking, so the overheads of multithreading becomes smaller over time. In fact, if a CPU has multiple cores, you might be wasting CPU power by not multitasking. Anyways, that design discussion belongs in a different text. It suffices to say here, that you can handle multiple channels with a single thread, using a Selector.</p>
<p>Here is an illustration of a thread using a Selector to handle 3 Channel’s:</p>
<p><img src="/en/pic/image-20190304111544951.png" alt="image-20190304111544951"></p>
<p>To use a <code>Selector</code> you register the <code>Channel</code>'s with it. Then you call it’s <code>select()</code> method. This method will block until there is an event ready for one of the registered channels. Once the method returns, the thread can then process these events. Examples of events are incoming connection, data received etc.</p>
<h2><span id="creating-a-selector">Creating a Selector</span></h2>
<p>You create a <code>Selector</code> by calling the <code>Selector.open()</code> method, like this:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure>
<h2><span id="registering-channels-with-the-selector">Registering Channels with the Selector</span></h2>
<p>In order to use a <code>Channel</code> with a <code>Selector</code> you must register the <code>Channel</code> with the <code>Selector</code>. This is done using the<code>SelectableChannel.register()</code> method, like this:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ);</span><br></pre></td></tr></table></figure>
<p>The <code>Channel</code> must be in non-blocking mode to be used with a <code>Selector</code>. This means that you cannot use <code>FileChannel</code>'s with a <code>Selector</code> since <code>FileChannel</code>'s cannot be switched into non-blocking mode. Socket channels will work fine though.</p>
<p>Notice the second parameter of the <code>register()</code> method. This is an “interest set”, meaning what events you are interested in listening for in the <code>Channel</code>, via the <code>Selector</code>. There are four different events you can listen for:</p>
<ol>
<li>Connect</li>
<li>Accept</li>
<li>Read</li>
<li>Write</li>
</ol>
<p>A channel that “fires an event” is also said to be “ready” for that event. So, a channel that has connected successfully to another server is “connect ready”. A server socket channel which accepts an incoming connection is “accept” ready. A channel that has data ready to be read is “read” ready. A channel that is ready for you to write data to it, is “write” ready.</p>
<p>These four events are represented by the four <code>SelectionKey</code>constants:</p>
<ol>
<li>SelectionKey.OP_CONNECT</li>
<li>SelectionKey.OP_ACCEPT</li>
<li>SelectionKey.OP_READ</li>
<li>SelectionKey.OP_WRITE</li>
</ol>
<p>If you are interested in more than one event, OR the constants together, like this:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure>
<p>I’ll return to the interest set a bit further down in this text.</p>
<h2><span id="selectionkey">SelectionKey</span></h2>
<p>As you saw in the previous section, when you register a <code>Channel</code>with a <code>Selector</code> the <code>register()</code> method returns a <code>SelectionKey</code> objects. This <code>SelectionKey</code> object contains a few interesting properties:</p>
<ul>
<li>The interest set</li>
<li>The ready set</li>
<li>The Channel</li>
<li>The Selector</li>
<li>An attached object (optional)</li>
</ul>
<p>I’ll describe these properties below.</p>
<h2><span id="interest-set">Interest Set</span></h2>
<p>The interest set is the set of events you are interested in “selecting”, as described in the section “Registering Channels with the Selector”. You can read and write that interest set via the <code>SelectionKey</code> like this:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> interestSet = selectionKey.interestOps();</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> isInterestedInAccept  = interestSet &amp; SelectionKey.OP_ACCEPT;</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInConnect = interestSet &amp; SelectionKey.OP_CONNECT;</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInRead    = interestSet &amp; SelectionKey.OP_READ;</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInWrite   = interestSet &amp; SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure>
<p>As you can see, you can AND the interest set with the given <code>SelectionKey</code> constant to find out if a certain event is in the interest set.</p>
<h2><span id="ready-set">Ready Set</span></h2>
<p>The ready set is the set of operations the channel is ready for. You will primarily be accessing the ready set after a selection. Selection is explained in a later section. You access the ready set like this:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> readySet = selectionKey.readyOps();</span><br></pre></td></tr></table></figure>
<p>You can test in the same way as with the interest set, what events / operations the channel is ready for. But, you can also use these four methods instead, which all reaturn a boolean:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">selectionKey.isAcceptable();</span><br><span class="line">selectionKey.isConnectable();</span><br><span class="line">selectionKey.isReadable();</span><br><span class="line">selectionKey.isWritable();</span><br></pre></td></tr></table></figure>
<h2><span id="channel-selector">Channel + Selector</span></h2>
<p>Accessing the channel + selector from the <code>SelectionKey</code> is trivial. Here is how it’s done:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Channel  channel  = selectionKey.channel();</span><br><span class="line"></span><br><span class="line">Selector selector = selectionKey.selector();</span><br></pre></td></tr></table></figure>
<h2><span id="attaching-objects">Attaching Objects</span></h2>
<p>You can attach an object to a <code>SelectionKey</code> this is a handy way of recognizing a given channel, or attaching further information to the channel. For instance, you may attach the <code>Buffer</code> you are using with the channel, or an object containing more aggregate data. Here is how you attach objects:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">selectionKey.attach(theObject);</span><br><span class="line"></span><br><span class="line">Object attachedObj = selectionKey.attachment();</span><br></pre></td></tr></table></figure>
<p>You can also attach an object already while registering the <code>Channel</code>with the <code>Selector</code>, in the <code>register()</code> method. Here is how that looks:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ, theObject);</span><br></pre></td></tr></table></figure>
<h2><span id="selecting-channels-via-a-selector">Selecting Channels via a Selector</span></h2>
<p>Once you have register one or more channels with a <code>Selector</code> you can call one of the <code>select()</code> methods. These methods return the channels that are “ready” for the events you are interested in (connect, accept, read or write). In other words, if you are interested in channels that are ready for reading, you will receive the channels that are ready for reading from the <code>select()</code> methods.</p>
<p>Here are the <code>select()</code> methods:</p>
<ul>
<li>int select()</li>
<li>int select(long timeout)</li>
<li>int selectNow()</li>
</ul>
<p><strong>select()</strong> blocks until at least one channel is ready for the events you registered for.</p>
<p><strong>select(long timeout)</strong> does the same as <code>select()</code> except it blocks for a maximum of <code>timeout</code> milliseconds (the parameter).</p>
<p><strong>selectNow()</strong> doesn’t block at all. It returns immediately with whatever channels are ready.</p>
<p>The <code>int</code> returned by the <code>select()</code> methods tells how many channels are ready. That is, how many channels that became ready since last time you called <code>select()</code>. If you call <code>select()</code> and it returns 1 because one channel has become ready, and you call <code>select()</code> one more time, and one more channel has become ready, it will return 1 again. If you have done nothing with the first channel that was ready, you now have 2 ready channels, but only one channel had become ready between each <code>select()</code> call.</p>
<h2><span id="selectedkeys">selectedKeys()</span></h2>
<p>Once you have called one of the <code>select()</code> methods and its return value has indicated that one or more channels are ready, you can access the ready channels via the “selected key set”, by calling the selectors <code>selectedKeys()</code> method. Here is how that looks:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br></pre></td></tr></table></figure>
<p>When you register a channel with a <code>Selector</code> the <code>Channel.register()</code> method returns a <code>SelectionKey</code> object. This key represents that channels registration with that selector. It is these keys you can access via the <code>selectedKeySet()</code> method. From the <code>SelectionKey</code>.</p>
<p>You can iterate this selected key set to access the ready channels. Here is how that looks:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line"></span><br><span class="line">Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(keyIterator.hasNext()) &#123;</span><br><span class="line">    </span><br><span class="line">    SelectionKey key = keyIterator.next();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was accepted by a ServerSocketChannel.</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was established with a remote server.</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for reading</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for writing</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    keyIterator.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This loop iterates the keys in the selected key set. For each key it tests the key to determine what the channel referenced by the key is ready for.</p>
<p>Notice the <code>keyIterator.remove()</code> call at the end of each iteration. The <code>Selector</code> does not remove the <code>SelectionKey</code>instances from the selected key set itself. You have to do this, when you are done processing the channel. The next time the channel becomes “ready” the <code>Selector</code> will add it to the selected key set again.</p>
<p>The channel returned by the <code>SelectionKey.channel()</code> method should be cast to the channel you need to work with, e.g a ServerSocketChannel or SocketChannel etc.</p>
<h2><span id="wakeup">wakeUp()</span></h2>
<p>A thread that has called the <code>select()</code> method which is blocked, can be made to leave the <code>select()</code> method, even if no channels are yet ready. This is done by having a different thread call the <code>Selector.wakeup()</code> method on the <code>Selector</code> which the first thread has called <code>select()</code> on. The thread waiting inside <code>select()</code>will then return immediately.</p>
<p>If a different thread calls <code>wakeup()</code> and no thread is currently blocked inside <code>select()</code>, the next thread that calls <code>select()</code> will “wake up” immediately.</p>
<h2><span id="close">close()</span></h2>
<p>When you are finished with the <code>Selector</code> you call its <code>close()</code>method. This closes the <code>Selector</code> and invalidates all <code>SelectionKey</code> instances registered with this <code>Selector</code>. The channels themselves are not closed.</p>
<h2><span id="full-selector-example">Full Selector Example</span></h2>
<p>Here is a full example which opens a <code>Selector</code>, registers a channel with it (the channel instantiation is left out), and keeps monitoring the <code>Selector</code> for “readiness” of the four events (accept, connect, read, write).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> readyChannels = selector.selectNow();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(readyChannels == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line"></span><br><span class="line">  Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(keyIterator.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">    SelectionKey key = keyIterator.next();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was accepted by a ServerSocketChannel.</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was established with a remote server.</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for reading</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for writing</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    keyIterator.remove();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><span id="filechannel">FileChannel</span></h1>
<p>A <code>FileChannel</code> cannot be set into non-blocking mode. It always runs in blocking mode.</p>
<h2><span id="opening-a-filechannel">Opening a FileChannel</span></h2>
<p>Before you can use a <code>FileChannel</code> you must open it. You cannot open a FileChannel directly. You need to obtain a FileChannel via an InputStream, OutputStream, or a RandomAccessFile. Here is how you open a FileChannel via a RandomAccessFile:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile aFile     = new RandomAccessFile(&quot;data/nio-data.txt&quot;, &quot;rw&quot;);</span><br><span class="line">FileChannel      inChannel = aFile.getChannel();</span><br></pre></td></tr></table></figure>
<h2><span id="reading-data-from-a-filechannel">Reading Data from a FileChannel</span></h2>
<p>To read data from a <code>FileChannel</code> you call one of the <code>read()</code>methods. Here is an example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(48);</span><br><span class="line"></span><br><span class="line">int bytesRead = inChannel.read(buf);</span><br></pre></td></tr></table></figure>
<p>First a <code>Buffer</code> is allocated. The data read from the <code>FileChannel</code> is read into the <code>Buffer</code>.</p>
<p>Second the <code>FileChannel.read()</code> method is called. This method reads data from the <code>FileChannel</code> into the <code>Buffer</code>. The <code>int</code>returned by the <code>read()</code> method tells how many bytes were witten into the <code>Buffer</code>. If -1 is returned, the end-of-file is reached.</p>
<h2><span id="writing-data-to-a-filechannel">Writing Data to a FileChannel</span></h2>
<p>Writing data to a <code>FileChannel</code> is done using the <code>FileChannel.write()</code> method, which takes a <code>Buffer</code> as parameter. Here is an example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String newData = &quot;New String to write to file...&quot; + System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(48);</span><br><span class="line">buf.clear();</span><br><span class="line">buf.put(newData.getBytes());</span><br><span class="line"></span><br><span class="line">buf.flip();</span><br><span class="line"></span><br><span class="line">while(buf.hasRemaining()) &#123;</span><br><span class="line">    channel.write(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Notice how the <code>FileChannel.write()</code> method is called inside a while-loop. There is no guarantee of how many bytes the <code>write()</code>method writes to the <code>FileChannel.</code> Therefore we repeat the <code>write()</code> call until the <code>Buffer</code> has no further bytes to write.</p>
<h2><span id="closing-a-filechannel">Closing a FileChannel</span></h2>
<p>When you are done using a <code>FileChannel</code> you must close it. Here is how that is done:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.close();</span><br></pre></td></tr></table></figure>
<h2><span id="filechannel-position">FileChannel Position</span></h2>
<p>When reading or writing to a <code>FileChannel</code> you do so at a specific position. You can obtain the current position of the <code>FileChannel</code>object by calling the <code>position()</code> method.</p>
<p>You can also set the position of the <code>FileChannel</code> by calling the <code>position(long pos)</code> method.</p>
<p>Here are two examples:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">long pos channel.position();</span><br><span class="line"></span><br><span class="line">channel.position(pos +123);</span><br></pre></td></tr></table></figure>
<p>If you set the position after the end of the file, and try to read from the channel, you will get -1 - the end-of-file marker.</p>
<p>If you set the position after the end of the file, and write to the channel, the file will be expanded to fit the position and written data. This may result in a “file hole”, where the physical file on the disk has gaps in the written data.</p>
<h2><span id="filechannel-size">FileChannel Size</span></h2>
<p>The <code>size()</code> method of the <code>FileChannel</code> object returns the file size of the file the channel is connected to. Here is a simple example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">long fileSize = channel.size();</span><br></pre></td></tr></table></figure>
<h2><span id="filechannel-truncate">FileChannel Truncate</span></h2>
<p>You can truncate a file by calling the <code>FileChannel.truncate()</code>method. When you truncate a file, you cut it off at a given length. Here is an example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.truncate(1024);</span><br></pre></td></tr></table></figure>
<p>This example truncates the file at 1024 bytes in length.</p>
<h2><span id="filechannel-force">FileChannel Force</span></h2>
<p>The <code>FileChannel.force()</code> method flushes all unwritten data from the channel to the disk. An operating system may cache data in memory for performance reasons, so you are not guaranteed that data written to the channel is actually written to disk, until you call the <code>force()</code> method.</p>
<p>The <code>force()</code> method takes a boolean as parameter, telling whether the file meta data (permission etc.) should be flushed too.</p>
<p>Here is an example which flushes both data and meta data:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.force(true);</span><br></pre></td></tr></table></figure>
<h1><span id="socketchannel">SocketChannel</span></h1>
<p>There are two ways a SocketChannel can be created:</p>
<ul>
<li>You open a SocketChannel and connect to a server somewhere on the internet.</li>
<li>A SocketChannel can be created when an incoming connection arrives at a ServerSocketChannel.</li>
</ul>
<h2><span id="opening-a-socketchannel">Opening a SocketChannel</span></h2>
<p>Here is how you open a <code>SocketChannel</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"http://jenkov.com"</span>, <span class="number">80</span>));</span><br></pre></td></tr></table></figure>
<h2><span id="closing-a-socketchannel">Closing a SocketChannel</span></h2>
<p>You close a <code>SocketChannel</code> after use by calling the <code>SocketChannel.close()</code> method. Here is how that is done:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socketChannel.close();</span><br></pre></td></tr></table></figure>
<h2><span id="reading-from-a-socketchannel">Reading from a SocketChannel</span></h2>
<p>To read data from a <code>SocketChannel</code> you call one of the <code>read()</code>methods. Here is an example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(48);</span><br><span class="line"></span><br><span class="line">int bytesRead = socketChannel.read(buf);</span><br></pre></td></tr></table></figure>
<p>First a <code>Buffer</code> is allocated. The data read from the <code>SocketChannel</code>is read into the <code>Buffer</code>.</p>
<p>Second the <code>SocketChannel.read()</code> method is called. This method reads data from the <code>SocketChannel</code> into the <code>Buffer</code>. The <code>int</code> returned by the <code>read()</code> method tells how many bytes were witten into the <code>Buffer</code>. If -1 is returned, the end-of-stream is reached (the connection is closed).</p>
<h2><span id="writing-to-a-socketchannel">Writing to a SocketChannel</span></h2>
<p>Writing data to a <code>SocketChannel</code> is done using the <code>SocketChannel.write()</code> method, which takes a <code>Buffer</code> as parameter. Here is an example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String newData = &quot;New String to write to file...&quot; + System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(48);</span><br><span class="line">buf.clear();</span><br><span class="line">buf.put(newData.getBytes());</span><br><span class="line"></span><br><span class="line">buf.flip();</span><br><span class="line"></span><br><span class="line">while(buf.hasRemaining()) &#123;</span><br><span class="line">    channel.write(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Notice how the <code>SocketChannel.write()</code> method is called inside a while-loop. There is no guarantee of how many bytes the <code>write()</code>method writes to the <code>SocketChannel</code>. Therefore we repeat the <code>write()</code> call until the <code>Buffer</code> has no further bytes to write.</p>
<h2><span id="non-blocking-mode">Non-blocking Mode</span></h2>
<p>You can set a <code>SocketChannel</code> into non-blocking mode. When you do so, you can call <code>connect()</code>, <code>read()</code> and <code>write()</code> in asynchronous mode.</p>
<h3><span id="connect">connect()</span></h3>
<p>If the <code>SocketChannel</code> is in non-blocking mode, and you call <code>connect()</code>, the method may return before a connection is established. To determine whether the connection is established, you can call the <code>finishConnect()</code> method, like this:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"http://jenkov.com"</span>, <span class="number">80</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(! socketChannel.finishConnect() )&#123;</span><br><span class="line">    <span class="comment">//wait, or do something else...    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="write">write()</span></h3>
<p>In non-blocking mode the <code>write()</code> method may return without having written anything. Therefore you need to call the <code>write()</code> method in a loop. But, since this is already being done in the previous write examples, no need to do anything differently here.</p>
<h3><span id="read">read()</span></h3>
<p>In non-blocking mode the <code>read()</code> method may return without having read any data at all. Therefore you need to pay attention to the returned <code>int</code>, which tells how many bytes were read.</p>
<h2><span id="non-blocking-mode-with-selectors">Non-blocking Mode with Selectors</span></h2>
<p>The non-blocking mode of <code>SocketChannel</code>'s works much better with <code>Selector</code>'s. By registering one or more <code>SocketChannel</code>'s with a <code>Selector</code>, you can ask the <code>Selector</code> for channels that are ready for reading, writing etc.</p>
<h1><span id="serversocketchannel">ServerSocketChannel</span></h1>
<p>A Java NIO ServerSocketChannel is a channel that can listen for incoming TCP connections, just like a ServerSocket in standard Java Networking. The ServerSocketChannel class is located in the java.nio.channels package.</p>
<p>Here is an example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line">serverSocketChannel.socket().bind(new InetSocketAddress(9999));</span><br><span class="line"></span><br><span class="line">while(true)&#123;</span><br><span class="line">    SocketChannel socketChannel =</span><br><span class="line">            serverSocketChannel.accept();</span><br><span class="line"></span><br><span class="line">    //do something with socketChannel...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="opening-a-serversocketchannel">Opening a ServerSocketChannel</span></h2>
<p>You open a <code>ServerSocketChannel</code> by calling the <code>ServerSocketChannel.open()</code> method. Here is how that looks:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br></pre></td></tr></table></figure>
<h2><span id="closing-a-serversocketchannel">Closing a ServerSocketChannel</span></h2>
<p>Closing a <code>ServerSocketChannel</code> is done by calling the <code>ServerSocketChannel.close()</code> method. Here is how that looks:</p>
<p>serverSocketChannel.close();</p>
<h2><span id="listening-for-incoming-connections">Listening for Incoming Connections</span></h2>
<p>Listening for incoming connections is done by calling the <code>ServerSocketChannel.accept()</code> method. When the <code>accept()</code> method returns, it returns a <code>SocketChannel</code> with an incoming connection. Thus, the <code>accept()</code> method blocks until an incoming connection arrives.</p>
<p>Since you are typically not interested in listening just for a single connection, you call the <code>accept()</code> inside a while-loop. Here is how that looks:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">while(true)&#123;</span><br><span class="line">    SocketChannel socketChannel =</span><br><span class="line">            serverSocketChannel.accept();</span><br><span class="line"></span><br><span class="line">    //do something with socketChannel...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Of course you would use some other stop-criteria than <code>true</code> inside the while-loop.</p>
<h2><span id="non-blocking-mode">Non-blocking Mode</span></h2>
<p>A <code>ServerSocketChannel</code> can be set into non-blocking mode. In non-blocking mode the <code>accept()</code> method returns immediately, and may thus return null, if no incoming connection had arrived. Therefore you will have to check if the returned <code>SocketChannel</code> is null. Here is an example:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line">serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9999</span>));</span><br><span class="line">serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    SocketChannel socketChannel =</span><br><span class="line">            serverSocketChannel.accept();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(socketChannel != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//do something with socketChannel...</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><span id="reference">Reference</span></h1>
<ul>
<li>Java NIO Tutorial - dehttp://tutorials.jenkov.com/java-nio/index.html</li>
</ul>

                

                <hr>
                <!-- Pager -->
                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/en/2019/09/17/Python-Basics-Simple-Data-Types/" data-toggle="tooltip" data-placement="top" title="[Python] Basics - Simple Data Types">&larr; Previous Post</a>
                        </li>
                    
                    
                        <li class="next">
                            <a href="/en/2019/01/06/IoT-Why Cloud Computing is not enough for IoT/" data-toggle="tooltip" data-placement="top" title="[IoT] Why Cloud Computing is not enough for IoT">Next Post &rarr;</a>
                        </li>
                    
                </ul>

                <!-- duoshuo Share start -->
                
                <!-- 多说 Share end-->

                <!-- 多说评论框 start -->
                
                <!-- 多说评论框 end -->

                <!-- disqus comment start -->
                
                    <div class="comment">
                        <div id="disqus_thread" class="disqus-thread"></div>
                    </div>
                
                <!-- disqus comment end -->
            </div>
            
            <!-- Tabe of Content -->
            <!-- Table of Contents -->

    
      <aside id="sidebar">
        <div id="toc" class="toc-article">
        <strong class="toc-title">Contents</strong>
        
          <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">Channels</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">1.1.</span> <span class="toc-nav-text">Channels and Buffers</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">1.2.</span> <span class="toc-nav-text">Types of Channels</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">2.</span> <span class="toc-nav-text">Example</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">3.</span> <span class="toc-nav-text">Buffers</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">3.1.</span> <span class="toc-nav-text">Basic Buffer Usage</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">3.1.1.</span> <span class="toc-nav-text">Buffer Capacity, Position and Limit</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">3.1.2.</span> <span class="toc-nav-text">Capacity</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">3.1.3.</span> <span class="toc-nav-text">Position</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">3.1.4.</span> <span class="toc-nav-text">Limit</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">3.2.</span> <span class="toc-nav-text">Buffer Types</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">3.3.</span> <span class="toc-nav-text">Allocating a Buffer</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">3.4.</span> <span class="toc-nav-text">Writing Data to a Buffer</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">3.5.</span> <span class="toc-nav-text">flip()</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">3.6.</span> <span class="toc-nav-text">Reading Data from a Buffer</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">3.7.</span> <span class="toc-nav-text">rewind()</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">3.8.</span> <span class="toc-nav-text">clear() and compact()</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">3.9.</span> <span class="toc-nav-text">mark() and reset()</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">3.10.</span> <span class="toc-nav-text">equals() and compareTo()</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">3.11.</span> <span class="toc-nav-text">equals()</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">3.12.</span> <span class="toc-nav-text">compareTo()</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">4.</span> <span class="toc-nav-text">Java NIO Scatter / Gather</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">4.1.</span> <span class="toc-nav-text">Scattering Reads</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">4.2.</span> <span class="toc-nav-text">Gathering Writes</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">5.</span> <span class="toc-nav-text">Java NIO Channel to Channel Transfers</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">5.1.</span> <span class="toc-nav-text">transferFrom()</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">5.2.</span> <span class="toc-nav-text">transferTo()</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">6.</span> <span class="toc-nav-text">Selectors</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">6.1.</span> <span class="toc-nav-text">Why Use a Selector?</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">6.2.</span> <span class="toc-nav-text">Creating a Selector</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">6.3.</span> <span class="toc-nav-text">Registering Channels with the Selector</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">6.4.</span> <span class="toc-nav-text">SelectionKey</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">6.5.</span> <span class="toc-nav-text">Interest Set</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">6.6.</span> <span class="toc-nav-text">Ready Set</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">6.7.</span> <span class="toc-nav-text">Channel + Selector</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">6.8.</span> <span class="toc-nav-text">Attaching Objects</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">6.9.</span> <span class="toc-nav-text">Selecting Channels via a Selector</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">6.10.</span> <span class="toc-nav-text">selectedKeys()</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">6.11.</span> <span class="toc-nav-text">wakeUp()</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">6.12.</span> <span class="toc-nav-text">close()</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">6.13.</span> <span class="toc-nav-text">Full Selector Example</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">7.</span> <span class="toc-nav-text">FileChannel</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">7.1.</span> <span class="toc-nav-text">Opening a FileChannel</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">7.2.</span> <span class="toc-nav-text">Reading Data from a FileChannel</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">7.3.</span> <span class="toc-nav-text">Writing Data to a FileChannel</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">7.4.</span> <span class="toc-nav-text">Closing a FileChannel</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">7.5.</span> <span class="toc-nav-text">FileChannel Position</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">7.6.</span> <span class="toc-nav-text">FileChannel Size</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">7.7.</span> <span class="toc-nav-text">FileChannel Truncate</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">7.8.</span> <span class="toc-nav-text">FileChannel Force</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">8.</span> <span class="toc-nav-text">SocketChannel</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">8.1.</span> <span class="toc-nav-text">Opening a SocketChannel</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">8.2.</span> <span class="toc-nav-text">Closing a SocketChannel</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">8.3.</span> <span class="toc-nav-text">Reading from a SocketChannel</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">8.4.</span> <span class="toc-nav-text">Writing to a SocketChannel</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">8.5.</span> <span class="toc-nav-text">Non-blocking Mode</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">8.5.1.</span> <span class="toc-nav-text">connect()</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">8.5.2.</span> <span class="toc-nav-text">write()</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">8.5.3.</span> <span class="toc-nav-text">read()</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">8.6.</span> <span class="toc-nav-text">Non-blocking Mode with Selectors</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">9.</span> <span class="toc-nav-text">ServerSocketChannel</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">9.1.</span> <span class="toc-nav-text">Opening a ServerSocketChannel</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">9.2.</span> <span class="toc-nav-text">Closing a ServerSocketChannel</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">9.3.</span> <span class="toc-nav-text">Listening for Incoming Connections</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">9.4.</span> <span class="toc-nav-text">Non-blocking Mode</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">10.</span> <span class="toc-nav-text">Reference</span></a></li></ol>
        
        </div>
      </aside>
    

                
            <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/en/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/en/tags/#Java" title="Java">Java</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">

                    
                        <li><a href="http://swsmile.info" target="_blank">My Chinese Blog</a></li>
                    
                </ul>
                
            </div>
        </div>
    </div>
</article>




<!-- disqus embedded js code start (one page only need to embed once) -->
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = "your-disqus-ID";
    var disqus_identifier = "http://swsmile.info/2019/03/04/Java-NIO/";
    var disqus_url = "http://swsmile.info/2019/03/04/Java-NIO/";

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<!-- disqus embedded js code start end -->




<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'hover',
          placement: 'left',
          icon: 'ℬ'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                

                

                
                    <li>
                        <a target="_blank" href="https://www.facebook.com/swsmile666">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-facebook fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                
                    <li>
                        <a target="_blank" href="https://github.com/swsmile">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                
                    <li>
                        <a target="_blank" href="https://www.linkedin.com/in/weishi1028">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-linkedin fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Wei Shi 2020 
                    <br>
                    Theme by <a href="http://huangxuan.me">Hux</a> 
                    <span style="display: inline-block; margin: 0 5px;">
                        <i class="fa fa-heart"></i>
                    </span> 
                    re-Ported by <a href="http://beantech.org">BeanTech</a> | 
                    <iframe style="margin-left: 2px; margin-bottom:-5px;" frameborder="0" scrolling="0" width="91px" height="20px" src="https://ghbtns.com/github-btn.html?user=YenYuHsuan&repo=hexo-theme-beantech&type=star&count=true">
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/en/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/en/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/en/js/hux-blog.min.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("http://swsmile.info/en/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->


<script>
    // dynamic User by Hux
    var _gaId = 'UA-78769787-2';
    var _gaDomain = 'en';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>




<!-- Baidu Tongji -->

<script>
    // dynamic User by Hux
    var _baId = '4481376a6b117446f0ad6f2b9b796afc';

    // Originial
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?" + _baId;
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
</script>






	<a id="rocket" href="#top" class=""></a>
	<script type="text/javascript" src="/en/js/totop.js?v=1.0.0" async=""></script>
    <script type="text/javascript" src="/en/js/toc.js?v=1.0.0" async=""></script>
<!-- Image to hack wechat -->
<img src="http://swsmile.info/en/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
